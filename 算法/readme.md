## 算法


### 时间复杂度
执行这个算法所需要的计算工作量，复杂度反映了程序执行时间随输入规模增长而增长的量级

### 大O计算法
T(n) = O(f(n))
fn(n) 可以的值为
- 常数型 O(1)
- 对数型 O(log n)
- 线性 O(n)
-  线性对数型 O(n log n) 排序算法的最优复杂度
- 多项式型 平方型O(n^2) 立方型O(n^3) o(n^K)
- 指数型 O(2^n) 立方底指数型O(3^n) k次底指数型O(k^n)
- 阶乘型 O(n!) 循环里面套递归

### 计算方法
- 只关注最高数量级，且与之系数也没有关系
- 事件复杂度分析，从内向外分析，从最深层开始分析，如果遇到函数调用，就要深入函数进行分析


算法执行所需的临时空间，不随变量大小而变化，空间复杂度为一个常量，表示为 O(1)


### 提示
在提示中给出的数据范围
- 2 <= nums.length <= 10^4
- -10^9 <= nums[i] <= 10^9
- -10^9 <= target <= 10^9
- 只会存在一个有效答案

对于 -10^9 <= nums[i] <= 10^9    -10^9 <= target <= 10^9 ，这两个提示，说明了数据范围，对于强数据类型的语言，要考虑能否存的下。

一般我们认为计算机3.5Ghz的频率，也就是一秒钟执行3.5*10^9次.
对于提示中的nums 小于10^4，说明了数据量，也就说明了时间复杂度不能超过O(n^2)。
因为（10^4）^2 = 10^9， 在一秒钟内，3.5*10^9 > 10^9，差不多能够处理。
也就是说，如果数据量在10^3，写出n^3的算法，就符合要求
10^7 的数据量，n log n 的算法也能符合要求
