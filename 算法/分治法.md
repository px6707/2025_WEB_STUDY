## 分治

### 快排
```js
function quickSork(arr, lo, hi){
    if(lo>=hi){
        return
    }
    const p = partition(arr, lo, hi)
    quickSork(arr, lo, p-1)
    quickSork(arr, p+1, hi)
}
function swap(arr, i, j){
    [arr[i], arr[j]] = [arr[j], arr[i]]
}
function partition(arr, lo, hi){
    const pIndex = lo
    const povit = arr[pIndex]
    // 支点元素放在最后
    swap(arr, pIndex, hi)

    // 从开头遍历
    // i代表第一个比支点大的位置
    let i = lo
    for(let j=lo; j<hi; j++){
        // 如果元素比支点小，
        if(arr[j]<povit){
            // 小元素放前面，大元素放后面
            swap(arr, i, j)
            // 当前的i是小于支点的了，所以+1
            i++
        }
    } 
    swap(arr, i, hi)
    return i
}


function partition(arr, lo, hi){
    const pindex= lo
    swap(arr, lo, pindex)
    const povit = arr[lo]

    let l = lo
    let r = hi

    while(l<r){
        while(l<r && arr[r]>povit){
            r--
        }
        arr[l] = arr[r]
        while(l<r && arr[l]<povit){
            l++
        }
        arr[r] = arr[l]
    }
    arr[l] = povit
    return l
}
```

### 找到数组中的第K个最多元素
```js
var findKthLargest = function(nums, k) {
    return sort(nums, 0, nums.length-1, nums.length-k)
};
function sort(nums, lo, hi, k){
    if(lo>= hi){
        console.log(nums, k)
        return nums[k]
    }
    const p = partition(nums, lo, hi)
    if(p>k){
        return sort(nums, lo, p-1, k)
    }else if(p===k){
        console.log('n', nums, p)
        return nums[p]
    }else{
        return sort(nums, p+1, hi, k)
    }
}
function swap(nums, lo, hi){
    [nums[lo], nums[hi]] = [nums[hi], nums[lo]]
}
function partition(nums, lo, hi){
    const pIndex = lo
    const povit = nums[pIndex]
    swap(nums, pIndex, hi)
    let i = lo
    for(let j = lo; j<hi; j++){
        if(nums[j]<povit){
            swap(nums, i, j)
            i++
        }
    }
    swap(nums, i, hi)
    return i
}
```