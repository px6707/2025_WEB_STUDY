## 动态规划

### 斐波那契数列

```js
// 时间复杂度为O(2^n)
function fib(n){
    if(n<=1){
        return 1
    }
    return fib(n-1) + fib(n-2)
}

// 优化算法， 时间复杂度O(n)， 因为每个数字只计算一次
var mem = []
function fib(n){
    if(n<=1){
        return 1
    }
    if(mem[n] !== undefined){
        return mem[n]
    }
    return mem[n] = fib(n-1) + fib(n-2)
}
``` 

#### 斐波那契数列动归写法
```js
function fib(n){
   const dp = []
   dp[0] = 0
   dp[1] = 1
   for(let i=2; i<=n; i++){
        // 定义动态转移方程
        dp[i] = dp[i-1] + dp[i-2]
   } 
   return dp[n]
}

function fib(n){
   let a=0,b=1;
   for(let i=2; i<=n; i++){
        const temp = b
        b = a+b
        a = temp
   } 
   return b
}

```

### 打家劫舍
```js
function rob(nums){
    const dp = []
    dp[0] = nums[0]
    dp[1] = Math.max(dp[0], nums[1])
    for(let i = 2; i<nums.length; i++){
        // 定义动态转移方程
        dp[i] = Math.max(dp[i-1], nums[i]+dp[i-2])
    }
    return dp[nums.length-1]
}

// 优化
function rob(nums){
    if(nums.length ===1){
        return nums[0]
    }
    let a = nums[0]
    let b = Math.max(a, nums[1]) 

    for(let i = 2; i<nums.length; i++){
        // 定义动态转移方
        const temp = b
        b = Math.max(b, nums[i]+ a)
        a = temp
    }
    return b
}
```

### 不同路径
```js
var uniquePaths = function(m, n) {
    const dp = new Array(m).fill(new Array(n).fill(0))
    for(let i = 1; i<m; i++){
        dp[i][0] = 1
    }
    for(let j = 1; j<n; j++){
        dp[0][j] = 1
    }
    for(let i = 1; i<m; i++){
        for(let j = 1; j<n; j++){
            dp[i][j]=dp[i-1][j]+dp[i][j-1]
        }
    }
    return dp[m-1][n-1]
};

// 优化
var uniquePaths = function(m, n) {
    const dp = new Array(n).fill(1);
    
    for(let i = 1; i < m; i++){
        for(let j = 1; j < n; j++){
            dp[j] = dp[j] + dp[j-1];
        }
    }
    return dp[n-1];
};
```